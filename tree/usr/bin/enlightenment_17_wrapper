#!/bin/bash
source /usr/lib/elive-tools/functions
#el_make_environment
. gettext.sh
TEXTDOMAIN="desktopwrapper"
export TEXTDOMAIN

# no need to enable since we have el_error & debug info
#set -x
#_el_debug="$EL_DEBUG"
#export EL_DEBUG=3

counter_crash_amount=0
counter_crash_fast_amount=0
limit_crash_amount=4
limit_crash_time=120
limit_logs_check="$(( 2 * 60 * 60 ))" # two hours
counter_logs_time_last="$( date +%s )"
# unused, don't enable it
#E_CONF_PROFILE="standard"

# Lock system (modified for this tool) {{{
lockfile="/tmp/.$(basename $0)-${USER}.lock"

exit_ok(){
    rm -f "$lockfile"
    kill -9 "$e_pid"
}
exit_error(){
    rm -f "$lockfile"
    kill -9 "$e_pid"
    el_error "exit error triggered"
}

if [[ -r "$lockfile" ]] ; then
    PROCCESS="$(cat $lockfile)"
else
    PROCCESS=" "
fi
# FIXME: if process is running do a while loop waiting (entire minute or equivalent) to see if finishes the previous process or exit)
if (ps up $PROCCESS) 1>/dev/null 2>&1 ; then
    el_error "$(basename $0) already running?\n$(ps aux | grep $0)"
    exit
else
    echo $$ > "$lockfile"
fi
# set a new lockfile no matter what
#echo $$ > "$lockfile"


# traps needs to be after the lock verification, in order to not remove it when we are already running
trap "exit_ok" EXIT
trap "exit_error" 1 3 5 6 14 15 ERR TERM


# end lock system }}}

# zenity wrapper to not block desktop
zenity(){
    local pong

    pong="$( timeout 10 enlightenment_remote -ping 2>/dev/null )"
    if [[ "$pong" = *"pong" ]] ; then
        if command zenity "$@" ; then
            return 0
        else
            return 1
        fi
    else
        el_error "unable to run zenity wrapper because E doesn't pong"
    fi
}


send_debug_reports(){
    # send debug reports {{{
    if [[ -s "/etc/elive/settings" ]] ; then
        source "/etc/elive/settings" 1>/dev/null 2>&1
    fi
    # if user has not configured the reports configurator is not a problem: el_error & others will ask about that (one time)
    if [[ -s "$HOME/.config/elive/settings" ]] ; then
        source "$HOME/.config/elive/settings"
    fi

    if [[ "$send_debug_reports" = "yes" ]] ; then
        #eliveversion="$( awk '$1 ~ /elive-version/ {($1="");print $0}' /etc/elive-version | sed 's/^\ //g' )"
        eliveversion="$( el_elive_version_get )"
        # create an unique identifier
        if el_check_sudo_automated ; then
            id="$( timeout 3 sudo blkid | grep -oP 'UUID="\K[^"]+' | sha256sum | awk '{print $1}' )"
        else
            id="$( ip a | grep -E "(link/ether|fe80)" | sha256sum | awk '{print $1}' )"
        fi

        if [[ -z "$send_debug_reports_email" ]] ; then
            send_debug_reports_email="anonymous:${id}"
        fi


        # send
        if ! { echo -e "ELIVE_DATA_TYPE: 1.0::${id}::transfer::text::E17_crash::0::::${send_debug_reports_email}::SIGSEV::$( dpkg -l | grep -E "^ii\s+e17-stable\W+" | awk '{print $3}' | head -1 )::${eliveversion}::" ; cat "$HOME/.e-crashdump.txt" ; } | nc www.elivecd.org 60001 -w 6 1>/dev/null 2>&1 ; then

        sleep 2
        if ! { echo -e "ELIVE_DATA_TYPE: 1.0::${id}::transfer::text::E17_crash::0::::${send_debug_reports_email}::SIGSEV::$( dpkg -l | grep -E "^ii\s+e17-stable\W+" | awk '{print $3}' | head -1 )::${eliveversion}::" ; cat "$HOME/.e-crashdump.txt" ; } | nc www.elivecd.org 60001 -w 6 1>/dev/null 2>&1 ; then

            sleep 4
            { echo -e "ELIVE_DATA_TYPE: 1.0::${id}::transfer::text::E17_crash::0::::${send_debug_reports_email}::SIGSEV::$( dpkg -l | grep -E "^ii\s+e17-stable\W+" | awk '{print $3}' | head -1 )::${eliveversion}::" ; cat "$HOME/.e-crashdump.txt" ; } | nc www.elivecd.org 60001 -w 6 1>/dev/null 2>&1

            fi
        fi
    fi

    # }}}
}

restart_desktop_configuration(){
    # elive-skel upgrade {{{
    elive-skel upgrade ".e"
    el_warning "elive-skel upgrade .e - versions:\n$(dpkg -l | grep -E "^ii.*(libefl1|e17-stable|e17|elive-tools|deliver|elive-desktop)" | awk '{print $2" : "$3}' )"

    el_config_restart
    # - elive-skel upgrade }}}
    # notify user {{{
    el_speak_text "a-live desktop configuration upgraded"

    zenity --info --text="$( eval_gettext "Your desktop configuration has been restored, the old configuration is backuped in:" ) $HOME/.e.old"

    # - notify user }}}
}

verify_desktop_health(){
    # E seems like to be unusable due to too much crashes {{{
    if ((is_e_restarted_fast_too_much)) ; then
        el_warning "E restarted fastly too much - versions:\n$(dpkg -l | grep -E "^ii.*(libefl1|e17-stable|e17|elive-tools|deliver|elive-desktop)" | awk '{print $2" : "$3}' )"

        # FIXME: i think that this doesn't shows, use bkp g instead from a previous backup
        if zenity --question --text="$( eval_gettext "Your desktop seems to have crashed too much, do you want to restart a new configuration?" )" ; then
            restart_desktop_configuration
        fi

        # restart counter
        is_e_restarted_fast_too_much=0
        el_config_save "is_e_restarted_fast_too_much"
    fi

    # }}}
}

#verify_configuration_validity(){
    ## verify configurations {{{
    ## TODO: check confs of different settings (one for each, like pager, ibox, etc)
    #el_check_variables "E_CONF_PROFILE"

    ## TODO: we can use enlightenment_remote -module-list | grep "pager -- Enabled" to know if module is loaded or not

    #if [[ -s "$HOME/.e/e17/config/$E_CONF_PROFILE/e.cfg" ]] ; then
        #cd "$HOME/.e/e17/config/$E_CONF_PROFILE"
        #eet -d e.cfg config e.cfg.src
        #while read -ru 3 line
        #do
            #el_debug "$line"
            #if [[ "$line" = *"group \"E_Config_Module\" struct {"* ]] ; then
                #el_warning "config structure"
            #fi
        #done 3<<< "$( cat "e.cfg.src")"


    #else
        #el_error "Invalid E profile using? $E_CONF_PROFILE"
    #fi
    ## - verify configurations }}}
    ## restore desktop {{{
    #if ((is_e_configuration_invalid)) ; then
        #if zenity --question --text="$( eval_gettext "Seems like your desktop has an invalid configuration. Do you want to restart to a new configuration?" )" ; then
            #restart_desktop_configuration
        #fi

        ## restart counter
        #is_e_configuration_invalid=0
        #el_config_save "is_e_configuration_invalid"
    #fi
    ## - restore desktop }}}
#}

send_e_crash_to_elive(){
    # report anonymous crashes to elive (with user's permission) {{{
    #local eliveversion send_debug_reports_email send_debug_reports id

    if [[ -s "$HOME/.e-crashdump.txt" ]] && el_verify_internet ; then

        counter_crash_time_last="$( echo "$(date +%s) - $( stat -c %Z "$HOME/.e-crashdump.txt" )" | LC_ALL=C bc -l | sed -e 's|\..*$||g' )"
        counter_crash_amount="$(( $counter_crash_amount + 1 ))"

        if [[ "$counter_crash_time_last" -lt "$limit_crash_time" ]] ; then
            counter_crash_fast_amount="$(( $counter_crash_fast_amount + 1 ))"
        else
            counter_crash_fast_amount=0
        fi

        if [[ "$counter_crash_fast_amount" -gt "$limit_crash_amount" ]] ; then
            is_e_restarted_fast_too_much=1
            el_config_save "is_e_restarted_fast_too_much"
        fi

        send_debug_reports
    fi

    rm -f "$HOME/.e-crashdump.txt"

    # }}}
}

restart_enlightenment(){
    # pre {{{
    local pid is_e_restarted fullprocess eliveversion

    # we had before anything useful to report?
    # note: send it before to kill (or the crashdump will have our kill instead)
    send_e_crash_to_elive

    # }}}
    # kill all our E processes running {{{
    while read -ru 3 pid
    do
        [[ -z "$pid" ]] && continue

        fullprocess="$( ps ux | grep -E "\s+$pid\s+" | grep -vE "(enlightenment_alert|e-crashdump)" )"

        # kill only if the alert is not shown
        if ! ps ux | grep -E "\s+$pid\s+" | grep -qsE "(enlightenment_alert|e-crashdump)" ; then

            el_error "E blocked, killing '$pid' to recover it: $fullprocess"
            kill -s SIGSEGV "$pid"

            is_e_restarted=1
        fi

    done 3<<< "$( ps ux | grep "/usr/bin/enlightenment$" | grep -vE "(enlightenment_alert|e-crashdump)" | awk '{print $2}' )"

    # }}}
    # notify user that E has been restarted by Elive {{{
    if ((is_e_restarted)) ; then
        # wait that desktop has restarted before to show the notification
        sleep 20

        # we never want this backtrace, so we killed it manually, no useful info here
        rm -f "$HOME/.e-crashdump.txt"

        #el_notify_user "Enlightnement Restarted" "Elive recovered a crash of your desktop saving your working state and opened windows. Thank you Elive!"
        # tell the user in a very nice fashion way
        #el_speak_text "a-live desktop initiated special recovery"
        el_speak_text "ai-live desktop initiated recovery"

        sleep 20
        notify-send -t 20000 "Enlightnement Restarted" "Elive recovered a crash of your desktop saving your working state and opened windows" &
        unset is_e_restarted
    fi


    # }}}
}

watch_enlightenment_blocked(){
    local pong

    # if we don't have pidof, enlightenment_start has finished so the loop ends and we exit from the script
    #while [[ -O "/proc/${e_pid}/cmdline" ]]
    while kill -0 "$e_pid"
    do
        pong="$( timeout 10 enlightenment_remote -ping 2>/dev/null )"
        if ! [[ "$pong" = *"pong" ]] ; then
            sleep 2

            pong="$( timeout 10 enlightenment_remote -ping 2>/dev/null )"
            if ! [[ "$pong" = *"pong" ]] ; then
                sleep 2

                pong="$( timeout 10 enlightenment_remote -ping 2>/dev/null )"
                if ! [[ "$pong" = *"pong" ]] ; then

                    restart_enlightenment
                fi
            fi
        fi

        # save if we are using a different profile
        #E_CONF_PROFILE="$( enlightenment_remote -default-profile-get )"
        #if [[ "$E_CONF_PROFILE" != "standard" ]] ; then
            #el_config_save "E_CONF_PROFILE"
        #fi

        # evalate if a check every X time
        counter_logs_time_now="$( date +%s )"
        if [[ "$counter_logs_time_now" -gt "$(( $counter_logs_time_last + $limit_logs_check ))" ]] ; then
            counter_logs_time_last="$( date +%s )"

            if [[ "$( du -s "$HOME/.xsession-errors" | awk '{print $1}' )" -gt 10000 ]] ; then
                : > "$HOME/.xsession-errors"
            fi
        fi

        # check every:
        LC_ALL=C sleep 20
    done
}

main(){
    # pre {{{

    # }}}
    # TODO:
    # - trap E that doesn't ping (kill -s SIGSEGV to restart)
    #           - implemented in eremote
    #       - don't ask in the gui if restart, just restart (F1 option)
    # - trap the returning signal by e17, and ask (restore conf?) (should be always 0 ?)
    #       - looks like its not returned as an error (enlightenment_start return is not enlightenment one)
    # - check for configurations to see if user broken something (each 5 minutes maybe could be a good thing)
    # - truncate .xsession-errors every X mb
    # - if multiple crashes (set a counter of crashes and amount of time), ask to the user if restore the default E configuration (like 3 in 1 minute, or 4 in 2 minutes)
    # - in case of sending debug & "anonymous", ask the user if wants to report debug data (and ask for email, so we can contact him), save this conf to /etc
    # XXX: done until here
    # if E has been run for more than X days (RAM usage grows over time) like 1 week, restart it -- or check the memory consumption better (so it can grow faster due to errors, or maybe not-so-needed)
    # incremental backups of E dir (bkp), with automatic restore if user breaks it (instead of restart E conf, which can be a good option too?)
    # include "speaking actions with el_speak_text -f, like: initiating special elive recovering
    #   - what if the user wants to disable them?
    # implement a special way to upgrade the system (in order that we can found bugs after the release, something like an wget or similar..)
    #
    #
    #

    #if [[ -d "$HOME/.e/e17" ]] ; then
        #cd "$HOME/.e/e17/config/standard"

        #eet -d e.cfg config e.cfg.src

        #if ! grep -qs "value \"icon_theme\" string: \"gnome\";" e.cfg.src ; then
            #zenity --warning --text="$( eval_gettext "Your icons seems to be wrongly configured, press ok to restart your configuration" )"
            #killall -9 enlightenment
            #rm -rf "$HOME/.e" "$HOME/.xsession-errors"
        #fi

        #rm -f e.cfg.src
    #fi

    el_config_get

    verify_desktop_health

    # not implemented yet
    #verify_configuration_validity


    #
    # Start E
    #

    rm -f "$HOME/.xsession-errors"

    #unset E_CONF_PROFILE
    #enlightenment_start "$@" 2>"$HOME/.xsession-errors" 1>/dev/null  &
    # TODO: maybe run it in a "while read line" so that we can parse all the results here?

    #EL_DEBUG="$_el_debug" enlightenment_start "$@" 2>&1 | tee "$HOME/.xsession-errors" &
    enlightenment_start "$@" 2>&1 | tee "$HOME/.xsession-errors" &
    # get the real pid of E
    while true
    do
        sleep 2

        # FIXME: what if more enlightenment's are running?
        e_pid="$( ps ux | grep -E "\s+$(which enlightenment)$" | grep -E "^${USER}\s+" | awk '{print $2}' | tail -1 )"

        # TODO: temporal check
        if ! [[ "$(pidof enlightenment)" = "$e_pid" ]] ; then
            el_warning "pidof enlightenment is not the same as the pid get with ps ux"
        fi

        # we have the pid
        #if ps ux | grep -qs "$e_pid" ; then
        if kill -0 "${e_pid}" ; then
            # check
            if ! [[ -O "/proc/${e_pid}/cmdline" ]] ; then
                el_error "pid exists as $e_pid but is not ours?"
            fi
            break
        fi
    done


    # wait that desktop finishes to start before to run checkers
    sleep 10

    # this watcher stops after no more enlightenment process is running
    watch_enlightenment_blocked

    # watcher checks the pid so this should always finish correctly
    wait
}

#
#  MAIN
#
main "$@"

# vim: set foldmethod=marker :

