#!/bin/bash
source /usr/lib/elive-tools/functions
# TODO:
set -x

send_e_crash_to_elive(){
    # report anonymous crashes to elive (with user's permission) {{{
    local eliveversion send_debug_reports_email send_debug_reports id
    # note: this needs to be run before to kill E (so it's us who kill it)

    if [[ -s "$HOME/.e-crashdump.txt" ]] && el_verify_internet ; then

        source "/etc/elive/settings" 1>/dev/null 2>&1

        if [[ "$send_debug_reports" = "yes" ]] ; then
            eliveversion="$( awk '$1 ~ /elive-version/ {($1="");print $0}' /etc/elive-version | sed 's/^\ //g' )"
            # create an unique identifier
            id="$( dd if=/dev/urandom bs=1k count=2 2>/dev/null | sha1sum | awk '{print $1}' )"

            # send
            if ! { echo -e "ELIVE_DATA_TYPE: 1.0::${id}::transfer::text::E17_crash::0::::${send_debug_reports_email}::SIGSEV::$( dpkg -l | grep -E "^ii\s+e17-stable\W+" | awk '{print $3}' | head -1 )::${eliveversion}::" ; cat "$HOME/.e-crashdump.txt" ; } | nc www.elivecd.org 60001 -w 6 ; then

                sleep 2
                if ! { echo -e "ELIVE_DATA_TYPE: 1.0::${id}::transfer::text::E17_crash::0::::${send_debug_reports_email}::SIGSEV::$( dpkg -l | grep -E "^ii\s+e17-stable\W+" | awk '{print $3}' | head -1 )::${eliveversion}::" ; cat "$HOME/.e-crashdump.txt" ; } | nc www.elivecd.org 60001 -w 6 ; then

                    sleep 4
                    { echo -e "ELIVE_DATA_TYPE: 1.0::${id}::transfer::text::E17_crash::0::::${send_debug_reports_email}::SIGSEV::$( dpkg -l | grep -E "^ii\s+e17-stable\W+" | awk '{print $3}' | head -1 )::${eliveversion}::" ; cat "$HOME/.e-crashdump.txt" ; } | nc www.elivecd.org 60001 -w 6

                fi
            fi
        fi
    fi

    rm -f "$HOME/.e-crashdump.txt"

    # }}}
}

restart_enlightenment(){
    # pre {{{
    local pid is_e_restarted fullprocess eliveversion

    # we had before anything useful to report?
    send_e_crash_to_elive

    # }}}
    # kill all our E processes running {{{
    while read -ru 3 pid
    do
        [[ -z "$pid" ]] && continue

        fullprocess="$( ps ux | grep -E "\s+$pid\s+" | grep -vE "(enlightenment_alert|e-crashdump)" )"

        # kill only if the alert is now shown
        if ! ps ux | grep -E "\s+$pid\s+" | grep -qsE "(enlightenment_alert|e-crashdump)" ; then

            el_error "E blocked, killing '$pid':  $fullprocess"
            kill -s SIGSEGV "$pid"

            is_e_restarted=1
        fi

    done 3<<< "$( ps ux | grep "/usr/bin/enlightenment$" | grep -vE "(enlightenment_alert|e-crashdump)" | awk '{print $2}' )"

    # }}}
    # notify user that E has been restarted by Elive {{{
    if ((is_e_restarted)) ; then
        # wait that desktop has restarted before to show the notification
        sleep 20

        # we never want this backtrace, so we killed it manually, no useful info here
        rm -f "$HOME/.e-crashdump.txt"

        el_notify_user "Enlightnement Restarted" "Elive recovered a crash of your desktop saving your works and opened windows. Thank you Elive!"
        unset is_e_restarted
    fi

    # }}}
}

watch_enlightenment_blocked(){
    local pong

    while pidof enlightenment 1>/dev/null
    do
        pong="$( enlightenment_remote -ping 2>/dev/null )"
        if ! [[ "$pong" = *"pong" ]] ; then
            sleep 2

            pong="$( enlightenment_remote -ping 2>/dev/null )"
            if ! [[ "$pong" = *"pong" ]] ; then
                sleep 2

                pong="$( enlightenment_remote -ping 2>/dev/null )"
                if ! [[ "$pong" = *"pong" ]] ; then

                    restart_enlightenment
                fi
            fi
        fi

        # check every:
        sleep 10
    done
}

main(){
    # pre {{{

    # }}}
    # TODO:
    # - trap E that doesn't ping (kill -s SIGSEGV to restart)
    #           - implemented in eremote
    #       - don't ask in the gui if restart, just restart (F1 option)
    # - trap the returning signal by e17, and ask (restore conf?) (should be always 0 ?)
    #       - looks like its not returned as an error (enlightenment_start return is not enlightenment one)
    # - check for configurations to see if user broken something (each 5 minutes maybe could be a good thing)
    # - truncate .xsession-errors very X mb
    #
    #
    #

    #if [[ -d "$HOME/.e/e17" ]] ; then
        #cd "$HOME/.e/e17/config/standard"

        #eet -d e.cfg config e.cfg.src

        #if ! grep -qs "value \"icon_theme\" string: \"gnome\";" e.cfg.src ; then
            #zenity --warning --text="$( eval_gettext "Your icons seems to be wrongly configured, press ok to restart your configuration" )"
            #killall -9 enlightenment
            #rm -rf "$HOME/.e" "$HOME/.xsession-errors"
        #fi

        #rm -f e.cfg.src
    #fi

    #enlightenment_start "$@" 2>"$HOME/.xsession-errors" 1>/dev/null  &
    enlightenment_start "$@" &
    # TODO: does the .xsession-errors is already filled without that option?

    # wait that desktop finishes to start before to run checkers
    sleep 20

    # this watcher stops after no more enlightenment process is running
    watch_enlightenment_blocked
}

#
#  MAIN
#
main "$@"

# vim: set foldmethod=marker :

