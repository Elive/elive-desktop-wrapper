#!/bin/bash
source /usr/lib/elive-tools/functions
#el_make_environment
. gettext.sh
TEXTDOMAIN="desktopwrapper"
export TEXTDOMAIN

# no need to enable since we have el_error & debug info
#export NOREPORTS=1
#set -x
#_el_debug="$EL_DEBUG"
#export EL_DEBUG=3
# we should not use this or we will always get exit errors ? no, we want to catch all the signals to correctly exit_error triggers
# seems like we don't need it at all, HUP signal is catched without it
#set -E

# TODO: every X time, delete the cached freedesktops (once per week?)
# TODO: check if user is using the default Elive wallapaper and otherwise do something (change it back? ask? ... ) using other wallpapers makes the desktop less usable due to color replacements

counter_crash_amount=0
counter_crash_fast_amount=0

limit_crash_amount=4
limit_crash_time=240 # previous crash happened in less than 4 minutes
limit_logs_check="$(( 4 * 60 * 60 ))" # four hours
limit_autoreload_check="$(( 4 * 24 * 60 * 60 ))" # 4 days
limit_upgrader_check="$(( 23 * 60 * 60 ))" # each day

# limit of time that E can be paused before to be considered a block
# FIXME: use bigger value if the computer is slow
limit_paused_time="60"
cpubogomips="$( grep bogomips /proc/cpuinfo | sed -e 's|^.*: ||g' -e 's|\..*$||g' | tr ' ' '\n' | grep "[[:digit:]]" | head -1 )"
# 3350 (1.66 nettop), 1800 (900mhz)
if [[ "$cpubogomips" -lt 1500 ]] ; then
    limit_paused_time="180"
else
    if [[ "$cpubogomips" -lt 1900 ]] ; then
        limit_paused_time="120"
    else
        if [[ "$cpubogomips" -lt 3500 ]] ; then
            limit_paused_time="90"
        fi
    fi
fi

if grep -qs "boot=live" "/proc/cmdline" ; then
    is_live=1
fi

counter_logs_time_last="$( LC_ALL=C  date +%s )"
counter_autoreload_time_last="$( LC_ALL=C date +%s )"
counter_upgrader_time_last="$( LC_ALL=C date +%s )"
pid_wrapper="$$"

exit_ok(){
    if ! [[ -d "/tmp/e-${USER}@0" ]] && ! [[ -d "/tmp/e-${USER}@1" ]] ; then
        killall ecomorph 1>/dev/null 2>&1 || killall -9 ecomorph 1>/dev/null 2>&1 || true
    fi
}
exit_error(){
    exit_status="$?"

    # TODO: remove
    # note: if user do "reboot" from a terminal in X, E exits with the signal 129, so maybe is a good thing to note these signals and tell the user that he didn't exited correctly
    # nope: if you shutdown from the menu you have the same signal
    #el_warning "${FUNCNAME} received signal $exit_status \n\nE instances:\n$(ps ux | grep -vE "(grep)" | grep enlightenment)"

    unset exit_status
    exit 0
}

# traps needs to be after the lock verification, in order to not remove it when we are already running
trap "exit_ok" EXIT
trap "exit_error" 3 5 6 14 15 TERM HUP


check_updated_configurations(){
    local package_e17conf_installed_version

    # get the package installed version
    #package_e17conf_installed_version="$( LC_ALL=C apt-cache madison e17-conf | awk -v FS='|' '{print $2}' | head -1 )"
    package_e17conf_installed_version="$( LC_ALL=C dpkg-query -W e17-conf | awk '{print $2}' | tail -1 )"
    read -r package_e17conf_installed_version <<< "$package_e17conf_installed_version"


    if [[ -n "$package_e17conf_installed_version" ]] ; then
        if [[ "$package_e17conf_installed_version_prev" ]] && [[ -d "$HOME/.e" ]] ; then
            if [[ "${package_e17conf_installed_version}" != "$package_e17conf_installed_version_prev" ]] ; then
                # ask if upgrade the E confs
                if timeout 180 zenity --question --text="$( eval_gettext "Upgrade Desktop? New configuration updates found! It's very suggested to upgrade it to get the Elive features, you will lose your personal settings like modules, keybindings, or desktop configurations will be removed. Upgrade it?" )" ; then

                    cd "$HOME/.e"
                    bkp remove 1>/dev/null 2>&1 || true
                    cd

                    elive-skel upgrade ".e"
                    sync
                    is_conf_upgraded=1
                fi

                # remember the new version
                package_e17conf_installed_version_prev="$package_e17conf_installed_version"
                el_config_save "package_e17conf_installed_version_prev"
            fi
        else
            # new conf, save it
            package_e17conf_installed_version_prev="$package_e17conf_installed_version"
            el_config_save "package_e17conf_installed_version_prev"
        fi
    fi

}

restart_desktop_configuration(){
    # elive-skel upgrade {{{
    if ((is_live)) ; then
        rm -r "$HOME/.e"
    else
        # TODO: here and all "restore": show the date of the backup
        if [[ -d "$HOME/.e" ]] \
            && [[ "$( cd "$HOME/.e" ; if LC_ALL=C bkp list | grep -qs " directory$" ; then echo yes ; else echo no ; fi )" = "yes" ]] \
            && timeout 40 zenity --question --text="$( eval_gettext "Do you want restore a recent backup of your own desktop configurations instead of importing a new conf?" )" ; then

            cd "$HOME/.e"
            bkp get
            cd
        else
            elive-skel upgrade ".e"
        fi
    fi

    # restart counter and variable
    is_e_restarted_fast_too_much=0
    el_config_save "is_e_restarted_fast_too_much"
    # - elive-skel upgrade }}}
    # notify user {{{
    if el_check_version_is_days_recent 40 ; then
        el_speak_text "a-live desktop configuration upgraded"
    fi

    timeout 50 zenity --info --text="$( eval_gettext "Your desktop configuration has been restored, the backup from the old configuration is stored in:" )\n$HOME/.e.old"

    # - notify user }}}
}

verify_desktop_health(){
    # E seems like to be unusable due to too much crashes {{{
    if ! [[ -d "$HOME/.e" ]] ; then
        return
    fi
    # no need to recover if new conf
    if ((is_conf_upgraded)) ; then
        unset is_conf_upgraded
        return
    fi

    # TODO FIXME: seems like this code is only run when the destkop starts? we want it to be run in loop too, so let's enalbe this for the next 3.x beta versions (check if destkop restarted too much in order to restart configurations)
    if ((is_e_restarted_fast_too_much)) ; then
        #el_speak_text "desktop restarted too much, suggested to start with a new configuration"

        # check and show specific messages about crashes before to suggest anything
        crashes_messages

        if timeout 40 zenity --question --text="$( eval_gettext "Your desktop seems to have recently crashed too much, do you want to restart to a new clean configuration?" )" ; then
            restart_desktop_configuration
        fi

        # restart counter
        is_e_restarted_fast_too_much=0
        el_config_save "is_e_restarted_fast_too_much"

        el_warning "E restarted fastly too much - versions:\n$(dpkg -l | grep -E "^ii.*(libefl1|e17-stable|e17|elive-tools|deliver|elive-desktop)" | awk '{print $2" : "$3}' )"
    else
        # always do a backup before to start, this will be run in the loop checker
        if ! ((is_live)) ; then
            if [[ -d "$HOME/.e" ]] && [[ "$( LC_ALL=C du -s "$HOME/.e" | awk '{print $1}' )" -gt 400 ]] ; then
                is_backup_wanted=1
            fi
        fi
    fi

    # was the shutdown forced?
    if [[ -e "/var/tmp/elivehealth/elive-system-shutdown-forced" ]] && grep -qs "^yes$" "/var/tmp/elivehealth/elive-system-shutdown-forced" ; then
        if zenity --question --text="$( eval_gettext "Restore backup? Your computer has been forced shutdown, this is very bad for your data and can break your desktop configurations. Do you want to recover it from a recent backup?" )" ; then
            true
        fi
        # remove the verification file
        echo "user notified pre" > "/var/tmp/elivehealth/elive-system-shutdown-forced"
    fi

    # }}}
}

#verify_configuration_validity(){
    ## verify configurations {{{
    ## TODO: check confs of different settings (one for each, like pager, ibox, etc)
    #el_check_variables "E_CONF_PROFILE"

    ## TODO: we can use enlightenment_remote -module-list | grep "pager -- Enabled" to know if module is loaded or not

    #if [[ -s "$HOME/.e/e17/config/$E_CONF_PROFILE/e.cfg" ]] ; then
        #cd "$HOME/.e/e17/config/$E_CONF_PROFILE"
        #eet -d e.cfg config e.cfg.src
        #while read -ru 3 line
        #do
            #el_debug "$line"
            #if [[ "$line" = *"group \"E_Config_Module\" struct {"* ]] ; then
                #el_warning "config structure"
            #fi
        #done 3<<< "$( cat "e.cfg.src")"


    #else
        #el_error "Invalid E profile using? $E_CONF_PROFILE"
    #fi
    ## - verify configurations }}}
    ## restore desktop {{{
    #if ((is_e_configuration_invalid)) ; then
        #if zenity --question --text="$( eval_gettext "Seems like your desktop has an invalid configuration. Do you want to restart to a new configuration?" )" ; then
            #restart_desktop_configuration
        #fi

        ## restart counter
        #is_e_configuration_invalid=0
        #el_config_save "is_e_configuration_invalid"
    #fi
    ## - restore desktop }}}
#}

crashes_messages(){
    if [[ -s "$HOME/.e-crashdump.txt" ]] ; then

        # some strange ATI cards that reports crashes:
        if grep -qs "dri/r300_dri\.so" "$HOME/.e-crashdump.txt" ; then
            notify-send -t 90000 "Desktop Drivers" "$( eval_gettext "Elive detected that you have an ATI graphic card, these cards are known in Linux by their multiple issues, we suggest to replace it for an nvidia card if you can, or another option if you still have problems is to disable the hardware accelerated rendering for your desktop and switch it to software mode, but your desktop will be less smooth and fast." )" &
        fi
    fi
}

crashes_watcher(){
    if [[ -s "$HOME/.e-crashdump.txt" ]] ; then
        counter_crash_time_last="$( echo "$(date +%s) - $( stat -c %Z "$HOME/.e-crashdump.txt" )" | LC_ALL=C bc -l | sed -e 's|\..*$||g' )"
        counter_crash_amount="$(( $counter_crash_amount + 1 ))"

        if [[ "$counter_crash_time_last" -lt "$limit_crash_time" ]] ; then
            counter_crash_fast_amount="$(( $counter_crash_fast_amount + 1 ))"
        else
            counter_crash_fast_amount=0
        fi

        if [[ "$counter_crash_fast_amount" -gt "$limit_crash_amount" ]] ; then
            is_e_restarted_fast_too_much=1
            el_config_save "is_e_restarted_fast_too_much"
        else
            # restart counter
            is_e_restarted_fast_too_much=0
            el_config_save "is_e_restarted_fast_too_much"
        fi

        # too much restarts? check confs and tell the user
        if ((is_e_restarted_fast_too_much)) ; then
            crashes_messages
        fi
    fi
}


send_e_crash_to_elive(){
    # report anonymous crashes to elive (with user's permission) {{{
    #local eliveversion send_debug_reports_email send_debug_reports id

    if ((is_e_restarted)) ; then
        unset is_e_restarted
    else
        # TODO: enable the dpkg && in the future (after to have received enough reoprts), so that the debug info will be included or otherwise not sent
            #&& dpkg -l | grep "^ii" | awk '{print $2}' | grep -qsE "e17(-stable)?-dbg" \
        if [[ -s "$HOME/.e-crashdump.txt" ]] \
            && el_verify_internet ; then
            crashes_watcher

            # send debug reports {{{
            if [[ -s "/etc/elive/settings" ]] ; then
                source "/etc/elive/settings" 1>/dev/null 2>&1
            fi
            # if user has not configured the reports configurator is not a problem: el_error & others will ask about that (one time)
            if [[ -s "$HOME/.config/elive/settings" ]] ; then
                source "$HOME/.config/elive/settings"
            fi

            if [[ "$send_debug_reports" = "yes" ]] ; then
                #eliveversion="$( awk '$1 ~ /elive-version/ {($1="");print $0}' /etc/elive-version | sed 's/^\ //g' )"
                eliveversion="$( el_elive_version_get )"
                # create an unique identifier
                if el_check_sudo_automated ; then
                    id="$( timeout 3 sudo blkid | grep -oP 'UUID="\K[^"]+' | sha256sum | awk '{print $1}' || true )"
                else
                    id="$( ip a | grep -E "(link/ether|fe80)" | sha256sum | awk '{print $1}' || true )"
                fi

                if [[ -z "$send_debug_reports_email" ]] ; then
                    send_debug_reports_email="anonymous:${id}"
                fi


                # send
                if ! { echo -e "ELIVE_DATA_TYPE: 1.0::${id}::transfer::text::E17_crash::0::::${send_debug_reports_email}::SIGSEV::$( dpkg -l | grep -E "^ii\s+e17-stable\W+" | awk '{print $3}' | head -1 )::${eliveversion}::" ; cat "$HOME/.e-crashdump.txt" ; } | nc www.elivecd.org 60001 -w 6 1>/dev/null 2>&1 ; then

                    LC_ALL=C sleep 2
                    if ! { echo -e "ELIVE_DATA_TYPE: 1.0::${id}::transfer::text::E17_crash::0::::${send_debug_reports_email}::SIGSEV::$( dpkg -l | grep -E "^ii\s+e17-stable\W+" | awk '{print $3}' | head -1 )::${eliveversion}::" ; cat "$HOME/.e-crashdump.txt" ; } | nc www.elivecd.org 60001 -w 6 1>/dev/null 2>&1 ; then

                        LC_ALL=C sleep 4
                        { echo -e "ELIVE_DATA_TYPE: 1.0::${id}::transfer::text::E17_crash::0::::${send_debug_reports_email}::SIGSEV::$( dpkg -l | grep -E "^ii\s+e17-stable\W+" | awk '{print $3}' | head -1 )::${eliveversion}::" ; cat "$HOME/.e-crashdump.txt" ; } | nc www.elivecd.org 60001 -w 6 1>/dev/null 2>&1

                        fi
                    fi
                fi

                # }}}

        fi
    fi

    rm -f "$HOME/.e-crashdump.txt"

    # }}}
}

restart_enlightenment(){
    # pre {{{
    local pid is_e_restarted fullprocess eliveversion is_silent

    if [[ "${1}" = "silent" ]] ; then
        is_silent=1
    fi
    # we had before anything useful to report?
    # note: send it before to kill (or the crashdump will have our kill instead)
    send_e_crash_to_elive

    # }}}
    # kill all our E processes running {{{
    while read -ru 3 pid
    do
        [[ -z "$pid" ]] && continue

        #fullprocess="$( ps ux | grep -E "\s+$pid\s+" | grep -vE "(enlightenment_alert|e-crashdump)" )"

        # kill only if the alert is not shown
        if ! ps ux | grep -qsE "\s+$pid\s+(enlightenment_alert|e-crashdump)" ; then

            kill -s SIGSEGV "$pid" 2>/dev/null || true
            is_e_restarted=1

            # TODO: delete
            #el_error "E blocked, killing '$pid' to recover it: $fullprocess"
        fi

    done 3<<< "$( ps ux | grep "/usr/bin/enlightenment$" | grep -vE "(enlightenment_alert|e-crashdump)" | awk '{print $2}' )"

    # }}}
    # notify user that E has been restarted by Elive {{{
    if ((is_e_restarted)) && ! ((is_silent)) ; then
        #el_notify_user "Enlightnement Restarted" "Elive recovered a crash of your desktop saving your working state and opened windows. Thank you Elive!"
        # tell the user in a very nice fashion way
        if el_check_version_is_days_recent 14 ; then
            el_speak_text "ai-live desktop initiated recovery"
        fi

        LC_ALL=C sleep 20
        notify-send -t 60000 "Enlightnement Restarted" "$( eval_gettext "Elive detected a failure and recovered your desktop saving your working windows. If you want to report an issue to Elive so we can fix it, please describe what you were doing before the recovery." )" &

        # see if we restarted too much, if so, it will be asked to recover configuration in the next startx
        crashes_watcher

        # this will delete the variable and the crashdump
        send_e_crash_to_elive

        # verify statuses TODO: enable it for the next 3.x beta versions (we dont want to have a flood of messages in the stable version so better to betatest it some time first)
        #verify_desktop_health

        # we never want this backtrace, so we killed it manually, no useful info here
        #rm -f "$HOME/.e-crashdump.txt"
    fi


    # }}}
}

watch_enlightenment_blocked(){
    local pong count

    # wait for things initiated {{{
    for count in $( seq 40 ) ; do
        pong="$( LC_ALL=C timeout 5 enlightenment_remote -ping 2>/dev/null || true )"
        if [[ "$pong" = *"pong" ]] ; then
            break
        else
            LC_ALL=C sleep 2
        fi
    done

    # }}}
    while true
    do
        unset pong

        # note: if E is running with a slow process, it can feel blocked too (like programmers-kb-layout-switch)
        # max time to see if E is not blocked: 48 seconds, we should not have anything pausing E for more than this time
        for count in $( seq $(( $limit_paused_time / 2 )) ) ; do
            pong="$( LC_ALL=C timeout 5 enlightenment_remote -ping 2>/dev/null || true )"
            if [[ "$pong" = *"pong" ]] ; then
                # pong is ok
                break
            else
                # note: we should only rely in our e_start_pid, which is the only one that is not closed until E really closes
                if LC_ALL=C kill -0 $e_start_pid 2>/dev/null ; then
                    # we have our E START still running
                    LC_ALL=C sleep 2
                else
                    # no pong and no pid, E should have been closed
                    break 2
                fi
            fi
        done

        # if we didn't had a pong in our max amount of attemps, restart
        if ! [[ "$pong" = *"pong" ]] ; then
            # note: this could happen too if dbus is not running under E
            restart_enlightenment
        fi

        #all good, don't bottleneck per loop
        LC_ALL=C sleep 4



        # did we wanted to do a backup?
        if ((is_backup_wanted)) ; then
            unset is_backup_wanted

            if [[ -d "$HOME/.e" ]] ; then
                # wait a bit more to correctly finish startups
                sleep 10
                enlightenment_remote -save

                cd "$HOME/.e"
                bkp remove 1>/dev/null 2>&1 || true
                sync
                bkp save 1>/dev/null 2>&1
                cd
            fi
        fi


        counter_time_now="$( LC_ALL=C date +%s )"

        # cleanup logs
        if [[ "$counter_time_now" -gt "$(( $counter_logs_time_last + $limit_logs_check ))" ]] ; then
            counter_logs_time_last="$( LC_ALL=C date +%s )"

            if [[ "$( du -s "$HOME/.xsession-errors" | awk '{print $1}' )" -gt 20000 ]] ; then
                #el_warning "cleaned xsession-errors file because has more than 20 MB"
                : > "$HOME/.xsession-errors"
            fi
        fi
        # restart E after some amount of time to free some memory
        if [[ "$counter_time_now" -gt "$(( $counter_autoreload_time_last + $limit_autoreload_check ))" ]] ; then
            counter_autoreload_time_last="$( LC_ALL=C date +%s )"
            restart_enlightenment silent
        fi

        # run elive-upgrader if new things are found
        if [[ "$counter_time_now" -gt "$(( $counter_upgrader_time_last + $limit_upgrader_check ))" ]] ; then
            counter_upgrader_time_last="$( LC_ALL=C date +%s )"
            # run elive-upgrader, only if user has it enabled on the autostart applications
            if grep -qs "elive-upgrader" "$HOME/.e/e17/applications/startup/.order" ; then
                elive-upgrader
            fi
        fi

    done
}

main(){
    # pre {{{


    # }}}

    # note: this can be nice but maybe the user has selected its own icon theme, so we don't want that
    #if [[ -d "$HOME/.e/e17" ]] ; then
        #cd "$HOME/.e/e17/config/standard"

        #eet -d e.cfg config e.cfg.src

        #if ! grep -qs "value \"icon_theme\" string: \"gnome\";" e.cfg.src ; then
            #zenity --warning --text="$( eval_gettext "Your icons seems to be wrongly configured, press ok to restart your configuration" )"
            #killall -9 enlightenment
            #rm -rf "$HOME/.e" "$HOME/.xsession-errors"
        #fi

        #rm -f e.cfg.src
    #fi

    el_config_get

    check_updated_configurations

    verify_desktop_health


    rm -f "$HOME/.xsession-errors"

    # not implemented yet
    #verify_configuration_validity


    #
    # Start E
    #
    if ((is_live)) ; then
        # do not save logs in live mode, reduce disk usage (specially useful for persistence)
        TEXTDOMAIN="" \
            is_e_restarted_fast_too_much="" \
            enlightenment_start "$@" &
        e_start_pid="$!"
    else
        TEXTDOMAIN="" \
            is_e_restarted_fast_too_much="" \
            enlightenment_start "$@" 1>"$HOME/.xsession-errors" 2>&1 &
        e_start_pid="$!"
    fi

    # wait that desktop finishes to start before to run checkers
    sleep 12

    # this watcher stops after no more enlightenment process is running
    watch_enlightenment_blocked

    # watcher checks the pid so this should always finish correctly, but we need to wait for E to close
    wait

    # trigger correctly the exit callbacks
    exit 0
}

#
#  MAIN
#
main "$@"

# vim: set foldmethod=marker :

